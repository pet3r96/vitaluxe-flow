name: Deploy Vitaluxe to AWS Lightsail

on:
  push:
    branches:
      - main

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production

    env:
      AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
      LIGHTSAIL_SERVICE_NAME: ${{ secrets.LIGHTSAIL_SERVICE_NAME }}
      VITE_SUPABASE_URL: ${{ secrets.VITE_SUPABASE_URL }}
      VITE_SUPABASE_PUBLISHABLE_KEY: ${{ secrets.VITE_SUPABASE_PUBLISHABLE_KEY }}

    steps:
      # üß© Step 1: Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v4

      # ‚úÖ Step 2: Validate Required Secrets
      - name: Validate Required Secrets
        run: |
          echo "Validating required secrets are present..."
          MISSING_SECRETS=false
          
          if [ -z "${{ secrets.AWS_ROLE_ARN }}" ]; then
            echo "ERROR: AWS_ROLE_ARN secret is missing"
            MISSING_SECRETS=true
          fi
          
          if [ -z "${{ secrets.AWS_REGION }}" ]; then
            echo "ERROR: AWS_REGION secret is missing"
            MISSING_SECRETS=true
          fi
          
          if [ -z "${{ secrets.ECR_REPOSITORY }}" ]; then
            echo "ERROR: ECR_REPOSITORY secret is missing"
            MISSING_SECRETS=true
          fi
          
          if [ -z "${{ secrets.LIGHTSAIL_SERVICE_NAME }}" ]; then
            echo "ERROR: LIGHTSAIL_SERVICE_NAME secret is missing"
            MISSING_SECRETS=true
          fi
          
          if [ -z "${{ secrets.VITE_SUPABASE_URL }}" ]; then
            echo "ERROR: VITE_SUPABASE_URL secret is missing"
            MISSING_SECRETS=true
          fi
          
          if [ -z "${{ secrets.VITE_SUPABASE_PUBLISHABLE_KEY }}" ]; then
            echo "ERROR: VITE_SUPABASE_PUBLISHABLE_KEY secret is missing"
            MISSING_SECRETS=true
          fi
          
          if [ "$MISSING_SECRETS" = true ]; then
            echo "Deployment aborted due to missing secrets"
            exit 1
          fi
          
          echo "All required secrets are present"

      # üîê Step 3: Configure AWS credentials via OIDC
      - name: Configure AWS Credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}
          audience: sts.amazonaws.com
          output-env-credentials: true

      # üê≥ Step 2: Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3



      # üì¶ Step 3: Cache Docker layers
      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      # üõ†Ô∏è Step 4: Build Docker image
      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          load: true
          tags: vitaluxe-app:latest
          build-args: |
            VITE_SUPABASE_URL=${{ secrets.VITE_SUPABASE_URL }}
            VITE_SUPABASE_PUBLISHABLE_KEY=${{ secrets.VITE_SUPABASE_PUBLISHABLE_KEY }}
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max

      # üß™ Step 6: Enhanced security scanning (OPTIONAL - only on main branch)
      - name: Scan Docker image for vulnerabilities
        if: github.ref == 'refs/heads/main'
        continue-on-error: true
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'vitaluxe-app:latest'
          format: 'table'
          exit-code: '0'
          ignore-unfixed: true
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH'
          output: 'trivy-results.txt'

      # üîë Step 5: Login & Push to Amazon ECR
      - name: Login & Push to ECR
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
        run: |
          echo "üîê Logging into Amazon ECR..."

          # Extract account ID and region from ECR_REPOSITORY
          ACCOUNT_ID=$(echo "$ECR_REPOSITORY" | cut -d'.' -f1)
          REGION=$(echo "$ECR_REPOSITORY" | cut -d'.' -f4)
          echo "Using AWS account: $ACCOUNT_ID"
          echo "Using region: $REGION"

          # Login to ECR using the extracted region
          aws ecr get-login-password --region "$REGION" | docker login --username AWS --password-stdin "$ACCOUNT_ID.dkr.ecr.$REGION.amazonaws.com"

          echo "üèóÔ∏è Tagging Docker image..."
          COMMIT_SHA=$(echo "${GITHUB_SHA::7}")
          docker tag vitaluxe-app:latest "$ECR_REPOSITORY:$COMMIT_SHA"
          docker tag vitaluxe-app:latest "$ECR_REPOSITORY:latest"

          echo "üì¶ Pushing image to ECR..."
          docker push "$ECR_REPOSITORY:$COMMIT_SHA"
          docker push "$ECR_REPOSITORY:latest"

      # üöÄ Step 6: Deploy to AWS Lightsail
      - name: Deploy to Lightsail
        env:
          LIGHTSAIL_SERVICE_NAME: ${{ secrets.LIGHTSAIL_SERVICE_NAME }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
        run: |
          echo "üöÄ Deploying new container version to Lightsail..."
          LIGHTSAIL_SERVICE_NAME=$(echo "$LIGHTSAIL_SERVICE_NAME" | tr -d '\n' | tr -d '\r' | xargs)
          echo "Using Lightsail service: $LIGHTSAIL_SERVICE_NAME"
          
          # Wait for any existing deployment to complete before starting new one
          echo "‚è≥ Checking for existing deployments..."
          for i in {1..30}; do
            CURRENT_DEPLOYMENT_STATUS=$(aws lightsail get-container-services \
              --service-name "$LIGHTSAIL_SERVICE_NAME" \
              --query "containerServices[0].nextDeployment.state" \
              --output text)
            
            echo "Current deployment status: $CURRENT_DEPLOYMENT_STATUS"
            
            if [[ "$CURRENT_DEPLOYMENT_STATUS" == "ACTIVE" || "$CURRENT_DEPLOYMENT_STATUS" == "FAILED" || "$CURRENT_DEPLOYMENT_STATUS" == "None" ]]; then
              echo "‚úÖ No deployment in progress, proceeding with new deployment..."
              break
            elif [[ "$CURRENT_DEPLOYMENT_STATUS" == "ACTIVATING" || "$CURRENT_DEPLOYMENT_STATUS" == "IN_PROGRESS" ]]; then
              echo "‚è≥ Deployment $i in progress, waiting 15s (attempt $i/30)..."
              sleep 15
            else
              echo "‚è≥ Deployment in unknown state ($CURRENT_DEPLOYMENT_STATUS), waiting 15s..."
              sleep 15
            fi
            
            if [ $i -eq 30 ]; then
              echo "‚ùå Timeout waiting for existing deployment to complete"
              exit 1
            fi
          done

          aws lightsail create-container-service-deployment \
            --service-name "$LIGHTSAIL_SERVICE_NAME" \
            --containers "{
              \"vitaluxe\": {
                \"image\": \"${ECR_REPOSITORY}:latest\",
                \"ports\": {\"8080\": \"HTTP\"}
              }
            }" \
            --public-endpoint "{
              \"containerName\": \"vitaluxe\",
              \"containerPort\": 8080,
              \"healthCheck\": {
                \"path\": \"/\",
                \"intervalSeconds\": 30,
                \"timeoutSeconds\": 10,
                \"healthyThreshold\": 2,
                \"unhealthyThreshold\": 2
              }
            }"

      # ‚è≥ Step 7: Wait for Deployment to Complete
      - name: Wait for Lightsail Deployment
        env:
          LIGHTSAIL_SERVICE_NAME: ${{ secrets.LIGHTSAIL_SERVICE_NAME }}
        run: |
          echo "‚è≥ Waiting for deployment to complete..."
          LIGHTSAIL_SERVICE_NAME=$(echo "$LIGHTSAIL_SERVICE_NAME" | tr -d '\n' | tr -d '\r' | xargs)

          SUCCESS=false
          for i in {1..30}; do
            # Check deployment status
            DEPLOYMENT_STATE=$(aws lightsail get-container-services \
              --service-name "$LIGHTSAIL_SERVICE_NAME" \
              --query "containerServices[0].nextDeployment.state" \
              --output text)
            
            SERVICE_STATE=$(aws lightsail get-container-services \
              --service-name "$LIGHTSAIL_SERVICE_NAME" \
              --query "containerServices[0].state" \
              --output text)
            
            echo "Service state: $SERVICE_STATE | Deployment state: $DEPLOYMENT_STATE (attempt $i/30)"
            
            # Success conditions:
            # - nextDeployment.state = "None" means deployment completed and became active
            # - service.state = "RUNNING" or "READY" confirms service is operational
            if [[ "$DEPLOYMENT_STATE" == "None" && ("$SERVICE_STATE" == "RUNNING" || "$SERVICE_STATE" == "READY") ]]; then
              SUCCESS=true
              echo "‚úÖ Deployment completed successfully! Service is $SERVICE_STATE."
              break
            elif [[ "$DEPLOYMENT_STATE" == "ACTIVATING" || "$SERVICE_STATE" == "DEPLOYING" ]]; then
              echo "Still deploying... waiting 15s"
              sleep 15
            elif [[ "$DEPLOYMENT_STATE" == "FAILED" ]]; then
              echo "‚ùå Deployment failed!"
              break
            else
              echo "Waiting for deployment to progress... (15s)"
              sleep 15
            fi
          done

          if [ "$SUCCESS" = false ]; then
            echo "‚ùå Deployment did not complete successfully within timeout period"
            exit 1
          fi

          echo "üîó Fetching service URL..."
          URL=$(aws lightsail get-container-services \
            --query "containerServices[?serviceName=='$LIGHTSAIL_SERVICE_NAME'].url" \
            --output text)
          echo "üåç Service URL: $URL"

      # üîç Step 8: Comprehensive Diagnostics
      - name: Service Diagnostics
        env:
          LIGHTSAIL_SERVICE_NAME: ${{ secrets.LIGHTSAIL_SERVICE_NAME }}
        run: |
          echo "üîç Running comprehensive service diagnostics..."
          LIGHTSAIL_SERVICE_NAME=$(echo "$LIGHTSAIL_SERVICE_NAME" | tr -d '\n' | tr -d '\r' | xargs)
          
          echo "üìä Service Status:"
          aws lightsail get-container-services \
            --service-name "$LIGHTSAIL_SERVICE_NAME" \
            --query "containerServices[0].{State:state,NextDeployment:nextDeployment.state,Url:url,Power:power,Scale:scale}" \
            --output table
          
          echo "\nüìã Container Details:"
          aws lightsail get-container-services \
            --service-name "$LIGHTSAIL_SERVICE_NAME" \
            --query "containerServices[0].currentDeployment.containers" \
            --output json
          
          echo "\nüìù Recent Container Logs:"
          # Get container logs (last 50 lines)
          LOG_GROUP=$(aws logs describe-log-groups --log-group-name-prefix "/aws/lightsail/$LIGHTSAIL_SERVICE_NAME" --query "logGroups[0].logGroupName" --output text 2>/dev/null || echo "")
          if [ ! -z "$LOG_GROUP" ] && [ "$LOG_GROUP" != "None" ]; then
            LOG_STREAM=$(aws logs describe-log-streams --log-group-name "$LOG_GROUP" --order-by LastEventTime --descending --max-items 1 --query "logStreams[0].logStreamName" --output text 2>/dev/null || echo "")
            if [ ! -z "$LOG_STREAM" ] && [ "$LOG_STREAM" != "None" ]; then
              aws logs get-log-events --log-group-name "$LOG_GROUP" --log-stream-name "$LOG_STREAM" --start-time $(date -d '5 minutes ago' +%s)000 --query "events[-50:].message" --output text 2>/dev/null || echo "No recent log events found"
            else
              echo "No log streams found"
            fi
          else
            echo "No log groups found"
          fi
          
          echo "\nüåê Testing Service Health:"
          URL=$(aws lightsail get-container-services \
            --query "containerServices[?serviceName=='$LIGHTSAIL_SERVICE_NAME'].url" \
            --output text)
          
          if [ ! -z "$URL" ]; then
            echo "Testing URL: $URL"
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 10 "$URL" || echo "000")
            echo "HTTP Status: $HTTP_STATUS"
            
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "‚úÖ Service is responding with HTTP 200"
            elif [ "$HTTP_STATUS" = "000" ]; then
              echo "‚ùå Service is not responding (connection timeout or DNS issue)"
            else
              echo "‚ö†Ô∏è  Service responded with HTTP $HTTP_STATUS"
            fi
          else
            echo "‚ùå Could not retrieve service URL"
          fi

      # üßæ Step 8: Final Summary
      - name: Deployment Summary
        if: always()
        run: |
          echo "‚úÖ Vitaluxe deployment process complete."
          echo "If any rollback occurred, review the Lightsail console for details."
