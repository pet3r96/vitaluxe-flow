name: Deploy Vitaluxe to AWS Lightsail

on:
  push:
    branches:
      - main

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production

    env:
      AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
      LIGHTSAIL_SERVICE_NAME: ${{ secrets.LIGHTSAIL_SERVICE_NAME }}

    steps:
      # üß© Step 1: Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v4


      # üîê Step 3: Configure AWS credentials via OIDC
      - name: Configure AWS Credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}
          audience: sts.amazonaws.com
          output-env-credentials: true

      # üê≥ Step 2: Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3



      # üì¶ Step 3: Cache Docker layers
      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      # üõ†Ô∏è Step 4: Build Docker image
      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          load: true
          tags: vitaluxe-app:latest
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max

      # üß™ Step 6: Enhanced security scanning (OPTIONAL - only on main branch)
      - name: Scan Docker image for vulnerabilities
        if: github.ref == 'refs/heads/main'
        continue-on-error: true
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'vitaluxe-app:latest'
          format: 'table'
          exit-code: '0'
          ignore-unfixed: true
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH'
          output: 'trivy-results.txt'

      # üîë Step 5: Login & Push to Amazon ECR
      - name: Login & Push to ECR
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
        run: |
          echo "üîê Logging into Amazon ECR..."

          # Extract account ID and region from ECR_REPOSITORY
          ACCOUNT_ID=$(echo "$ECR_REPOSITORY" | cut -d'.' -f1)
          REGION=$(echo "$ECR_REPOSITORY" | cut -d'.' -f4)
          echo "Using AWS account: $ACCOUNT_ID"
          echo "Using region: $REGION"

          # Login to ECR using the extracted region
          aws ecr get-login-password --region "$REGION" | docker login --username AWS --password-stdin "$ACCOUNT_ID.dkr.ecr.$REGION.amazonaws.com"

          echo "üèóÔ∏è Tagging Docker image..."
          COMMIT_SHA=$(echo "${GITHUB_SHA::7}")
          docker tag vitaluxe-app:latest "$ECR_REPOSITORY:$COMMIT_SHA"
          docker tag vitaluxe-app:latest "$ECR_REPOSITORY:latest"

          echo "üì¶ Pushing image to ECR..."
          docker push "$ECR_REPOSITORY:$COMMIT_SHA"
          docker push "$ECR_REPOSITORY:latest"

      # üöÄ Step 6: Deploy to AWS Lightsail
      - name: Deploy to Lightsail
        env:
          LIGHTSAIL_SERVICE_NAME: ${{ secrets.LIGHTSAIL_SERVICE_NAME }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
        run: |
          echo "üöÄ Deploying new container version to Lightsail..."
          LIGHTSAIL_SERVICE_NAME=$(echo "$LIGHTSAIL_SERVICE_NAME" | tr -d '\n' | tr -d '\r' | xargs)
          echo "Using Lightsail service: $LIGHTSAIL_SERVICE_NAME"

          aws lightsail create-container-service-deployment \
            --service-name "$LIGHTSAIL_SERVICE_NAME" \
            --containers "{
              \"vitaluxe\": {
                \"image\": \"${ECR_REPOSITORY}:latest\",
                \"ports\": {\"80\": \"HTTP\"}
              }
            }" \
            --public-endpoint "{
              \"containerName\": \"vitaluxe\",
              \"containerPort\": 80
            }"

      # ‚è≥ Step 7: Wait for Lightsail Deployment & Handle Rollback
      - name: Wait for Lightsail Deployment (with rollback)
        env:
          LIGHTSAIL_SERVICE_NAME: ${{ secrets.LIGHTSAIL_SERVICE_NAME }}
        run: |
          echo "‚è≥ Waiting for deployment to finish..."
          LIGHTSAIL_SERVICE_NAME=$(echo "$LIGHTSAIL_SERVICE_NAME" | tr -d '\n' | tr -d '\r' | xargs)

          SUCCESS=false
          for i in {1..10}; do
            # Get the full service details to better understand the state
            SERVICE_DETAILS=$(aws lightsail get-container-services \
              --service-name "$LIGHTSAIL_SERVICE_NAME" \
              --output json)
            
            # Extract current state and next deployment state
            CURRENT_STATE=$(echo "$SERVICE_DETAILS" | jq -r '.containerServices[0].state // "UNKNOWN"')
            NEXT_DEPLOYMENT_STATE=$(echo "$SERVICE_DETAILS" | jq -r '.containerServices[0].nextDeployment.state // "UNKNOWN"')
            
            echo "Current service state: $CURRENT_STATE"
            echo "Next deployment state: $NEXT_DEPLOYMENT_STATE"
            
            # Check if deployment is successful
            if [[ "$CURRENT_STATE" == "RUNNING" && "$NEXT_DEPLOYMENT_STATE" == "ACTIVE" ]]; then
              SUCCESS=true
              echo "‚úÖ Deployment successful! Service is running."
              break
            elif [[ "$CURRENT_STATE" == "READY" ]]; then
              SUCCESS=true
              echo "‚úÖ Deployment successful! Service is ready."
              break
            elif [[ "$CURRENT_STATE" == "DEPLOYING" || "$NEXT_DEPLOYMENT_STATE" == "ACTIVATING" ]]; then
              echo "Still deploying... waiting 10s (attempt $i/10)"
              sleep 10
            elif [[ "$CURRENT_STATE" == "PENDING" ]]; then
              echo "Service is pending... waiting 10s (attempt $i/10)"
              sleep 10
            else
              echo "‚ö†Ô∏è Unexpected state: $CURRENT_STATE (next: $NEXT_DEPLOYMENT_STATE)"
              # Wait a bit more to see if it resolves
              if [ $i -lt 5 ]; then
                echo "Waiting a bit more to see if state resolves..."
                sleep 10
              else
                break
              fi
            fi
          done

          if [ "$SUCCESS" = false ]; then
            echo "‚ùå Deployment failed or timed out ‚Äî attempting rollback..."
            
            # Wait a bit more to ensure the current deployment has fully failed
            echo "Waiting 30s to ensure current deployment has failed..."
            sleep 30
            
            # Get the list of deployments and find the previous version
            DEPLOYMENTS=$(aws lightsail get-container-service-deployments \
              --service-name "$LIGHTSAIL_SERVICE_NAME" \
              --output json)
            
            # Get the second most recent deployment version (previous working version)
            PREV_VERSION=$(echo "$DEPLOYMENTS" | jq -r '.deployments | sort_by(.createdAt) | reverse | .[1].version' || echo "")
            
            if [ -z "$PREV_VERSION" ] || [ "$PREV_VERSION" == "null" ]; then
              echo "‚ö†Ô∏è No previous deployment found to rollback to."
              echo "Current deployment status:"
              aws lightsail get-container-services --service-name "$LIGHTSAIL_SERVICE_NAME"
              exit 1
            fi
            
            echo "üîÑ Rolling back to deployment version: $PREV_VERSION"
            
            # Get the previous deployment configuration
            PREV_CONFIG=$(echo "$DEPLOYMENTS" | jq -r ".deployments[] | select(.version == $PREV_VERSION)")
            PREV_CONTAINERS=$(echo "$PREV_CONFIG" | jq -r '.containers')
            PREV_ENDPOINT=$(echo "$PREV_CONFIG" | jq -r '.publicEndpoint')
            
            # Redeploy using the previous configuration
            aws lightsail create-container-service-deployment \
              --service-name "$LIGHTSAIL_SERVICE_NAME" \
              --containers "$PREV_CONTAINERS" \
              --public-endpoint "$PREV_ENDPOINT"
            
            echo "üåÄ Rollback initiated. Waiting 60s before verifying..."
            sleep 60
            
            # Check rollback status
            ROLLBACK_DETAILS=$(aws lightsail get-container-services \
              --service-name "$LIGHTSAIL_SERVICE_NAME" \
              --output json)
            ROLLBACK_STATE=$(echo "$ROLLBACK_DETAILS" | jq -r '.containerServices[0].state // "UNKNOWN"')
            echo "Post-rollback status: $ROLLBACK_STATE"
            
            if [[ "$ROLLBACK_STATE" == "RUNNING" ]]; then
              echo "‚úÖ Rollback successful. Service restored to version $PREV_VERSION."
            else
              echo "‚ö†Ô∏è Rollback executed but service not yet running. Check Lightsail console."
            fi
            
            exit 1
          fi

          echo "üîó Fetching service URL..."
          URL=$(aws lightsail get-container-services \
            --query "containerServices[?serviceName=='$LIGHTSAIL_SERVICE_NAME'].url" \
            --output text)
          echo "üåç Service URL: $URL"

      # üßæ Step 8: Final Summary
      - name: Deployment Summary
        if: always()
        run: |
          echo "‚úÖ Vitaluxe deployment process complete."
          echo "If any rollback occurred, review the Lightsail console for details."
