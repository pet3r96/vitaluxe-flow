name: Deploy Vitaluxe to AWS Lightsail

on:
  workflow_dispatch:  # Manual trigger
  push:
    branches:
      - main  # Auto-deploy on push to main

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production

    env:
      AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
      LIGHTSAIL_SERVICE_NAME: ${{ secrets.LIGHTSAIL_SERVICE_NAME }}
      VITE_SUPABASE_URL: ${{ secrets.VITE_SUPABASE_URL }}
      VITE_SUPABASE_PUBLISHABLE_KEY: ${{ secrets.VITE_SUPABASE_PUBLISHABLE_KEY }}

    steps:
      # üß© Step 1: Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v4

      # ‚úÖ Step 2: Validate Required Secrets
      - name: Validate Required Secrets
        run: |
          echo "Validating required secrets are present..."
          MISSING_SECRETS=false
          
          if [ -z "${{ secrets.AWS_ROLE_ARN }}" ]; then
            echo "ERROR: AWS_ROLE_ARN secret is missing"
            MISSING_SECRETS=true
          fi
          
          if [ -z "${{ secrets.AWS_REGION }}" ]; then
            echo "ERROR: AWS_REGION secret is missing"
            MISSING_SECRETS=true
          fi
          
          if [ -z "${{ secrets.ECR_REPOSITORY }}" ]; then
            echo "ERROR: ECR_REPOSITORY secret is missing"
            MISSING_SECRETS=true
          fi
          
          if [ -z "${{ secrets.LIGHTSAIL_SERVICE_NAME }}" ]; then
            echo "ERROR: LIGHTSAIL_SERVICE_NAME secret is missing"
            MISSING_SECRETS=true
          fi
          
          if [ -z "${{ secrets.VITE_SUPABASE_URL }}" ]; then
            echo "ERROR: VITE_SUPABASE_URL secret is missing"
            MISSING_SECRETS=true
          fi
          
          if [ -z "${{ secrets.VITE_SUPABASE_PUBLISHABLE_KEY }}" ]; then
            echo "ERROR: VITE_SUPABASE_PUBLISHABLE_KEY secret is missing"
            MISSING_SECRETS=true
          fi
          
          if [ "$MISSING_SECRETS" = true ]; then
            echo "Deployment aborted due to missing secrets"
            exit 1
          fi
          
          echo "All required secrets are present"

      # üîê Step 3: Configure AWS credentials via OIDC
      - name: Configure AWS Credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}
          audience: sts.amazonaws.com
          output-env-credentials: true

      # üîß Step 3.5: Parse ECR Repository Details
      - name: Parse ECR Repository Details
        run: |
          echo "üîß Parsing ECR Repository details..."
          RAW_ECR_REPO="${{ secrets.ECR_REPOSITORY }}"

          # Discover AWS account ID if not provided in the repo string
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          REGION="${{ secrets.AWS_REGION }}"

          # Support both full ECR URI and plain repo name
          if [[ "$RAW_ECR_REPO" =~ ^[0-9]+\.dkr\.ecr\..+\.amazonaws\.com/.+ ]]; then
            # Full URI provided
            ECR_REPOSITORY_URI="$RAW_ECR_REPO"
            ECR_ACCOUNT_ID=$(echo "$RAW_ECR_REPO" | cut -d'.' -f1)
            ECR_REGION=$(echo "$RAW_ECR_REPO" | cut -d'.' -f4)
            REPO_NAME=$(echo "$RAW_ECR_REPO" | cut -d'/' -f2)
          else
            # Only repo name provided -> construct full URI
            REPO_NAME="$RAW_ECR_REPO"
            ECR_ACCOUNT_ID="$ACCOUNT_ID"
            ECR_REGION="$REGION"
            ECR_REPOSITORY_URI="$ECR_ACCOUNT_ID.dkr.ecr.$ECR_REGION.amazonaws.com/$REPO_NAME"
          fi

          echo "Parsed ECR details:"
          echo "  Account ID: $ECR_ACCOUNT_ID"
          echo "  Region: $ECR_REGION"
          echo "  Repository Name: $REPO_NAME"
          echo "  Full URI: $ECR_REPOSITORY_URI"

          # Export to GITHUB_ENV for use in subsequent steps
          echo "ECR_ACCOUNT_ID=$ECR_ACCOUNT_ID" >> $GITHUB_ENV
          echo "ECR_REGION=$ECR_REGION" >> $GITHUB_ENV
          echo "REPO_NAME=$REPO_NAME" >> $GITHUB_ENV
          echo "ECR_REPOSITORY_URI=$ECR_REPOSITORY_URI" >> $GITHUB_ENV

      # üîç Step 4: Verify AWS CLI and Permissions
      - name: Verify AWS Setup
        run: |
          echo "üîç Verifying AWS CLI setup..."
          aws --version
          echo "Current AWS region: $(aws configure get region)"
          echo "Current AWS account: $(aws sts get-caller-identity --query Account --output text)"
          
          echo "üîç Testing Lightsail permissions..."
          aws lightsail get-container-services --query "containerServices[].serviceName" --output table || echo "Lightsail access test failed"
          
          echo "üîç Testing ECR permissions in region $ECR_REGION..."
          aws ecr describe-repositories --region "$ECR_REGION" --query "repositories[].repositoryName" --output table || echo "ECR access test failed"

      # üê≥ Step 2: Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3



      # üì¶ Step 3: Cache Docker layers
      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      # üõ†Ô∏è Step 4: Build Docker image
      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          load: true
          tags: vitaluxe-app:latest
          build-args: |
            VITE_SUPABASE_URL=${{ secrets.VITE_SUPABASE_URL }}
            VITE_SUPABASE_PUBLISHABLE_KEY=${{ secrets.VITE_SUPABASE_PUBLISHABLE_KEY }}
            VITE_BUILD_ID=${{ github.sha }}
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max

      # üß™ Step 6: Enhanced security scanning (OPTIONAL - only on main branch)
      - name: Scan Docker image for vulnerabilities
        if: github.ref == 'refs/heads/main'
        continue-on-error: true
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'vitaluxe-app:latest'
          format: 'table'
          exit-code: '0'
          ignore-unfixed: true
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH'
          output: 'trivy-results.txt'

      # üîë Step 5: Login & Push to Amazon ECR
      - name: Login & Push to ECR
        run: |
          echo "üîê Logging into Amazon ECR..."
          echo "Using AWS account: $ECR_ACCOUNT_ID"
          echo "Using ECR region: $ECR_REGION"
          echo "Using repository: $REPO_NAME"
          echo "Full ECR URI: $ECR_REPOSITORY_URI"

          # Ensure repository exists
          if ! aws ecr describe-repositories --region "$ECR_REGION" --repository-names "$REPO_NAME" >/dev/null 2>&1; then
            echo "üì¶ ECR repository '$REPO_NAME' not found in $ECR_REGION. Creating it..."
            aws ecr create-repository --region "$ECR_REGION" --repository-name "$REPO_NAME" >/dev/null
            echo "‚úÖ Repository created"
          else
            echo "‚úÖ ECR repository exists"
          fi

          # Login to ECR using the parsed region
          aws ecr get-login-password --region "$ECR_REGION" | docker login --username AWS --password-stdin "$ECR_ACCOUNT_ID.dkr.ecr.$ECR_REGION.amazonaws.com"

          echo "üèóÔ∏è Tagging Docker image..."
          COMMIT_SHA=$(echo "${GITHUB_SHA::7}")
          docker tag vitaluxe-app:latest "$ECR_REPOSITORY_URI:$COMMIT_SHA"
          docker tag vitaluxe-app:latest "$ECR_REPOSITORY_URI:latest"

          echo "üì¶ Pushing image to ECR..."
          docker push "$ECR_REPOSITORY_URI:$COMMIT_SHA"
          docker push "$ECR_REPOSITORY_URI:latest"

      # üöÄ Step 6: Deploy to AWS Lightsail
      - name: Deploy to Lightsail
        env:
          LIGHTSAIL_SERVICE_NAME: ${{ secrets.LIGHTSAIL_SERVICE_NAME }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
        run: |
          echo "üöÄ Deploying new container version to Lightsail..."
          LIGHTSAIL_SERVICE_NAME=$(echo "$LIGHTSAIL_SERVICE_NAME" | tr -d '\n' | tr -d '\r' | xargs)
          echo "Using Lightsail service: $LIGHTSAIL_SERVICE_NAME"
          
          # Debug: Check if service exists
          echo "üîç Checking if Lightsail service exists..."
          SERVICE_CHECK=$(aws lightsail get-container-services --service-name "$LIGHTSAIL_SERVICE_NAME" 2>&1)
          if [ $? -ne 0 ]; then
            echo "‚ùå Lightsail service '$LIGHTSAIL_SERVICE_NAME' not found or accessible"
            echo "Service check result: $SERVICE_CHECK"
            echo "Available services:"
            aws lightsail get-container-services --query "containerServices[].serviceName" --output table
            exit 1
          fi
          
          # Debug: Check current service state
          echo "üîç Checking current service state..."
          CURRENT_STATE=$(aws lightsail get-container-services --service-name "$LIGHTSAIL_SERVICE_NAME" --query "containerServices[0].state" --output text)
          NEXT_DEPLOYMENT=$(aws lightsail get-container-services --service-name "$LIGHTSAIL_SERVICE_NAME" --query "containerServices[0].nextDeployment.state" --output text)
          echo "Current service state: $CURRENT_STATE"
          echo "Next deployment state: $NEXT_DEPLOYMENT"
          
          # If there's an active deployment, wait for it to complete
          if [[ "$NEXT_DEPLOYMENT" != "None" && "$NEXT_DEPLOYMENT" != "FAILED" ]]; then
            echo "‚ö†Ô∏è  There's an active deployment in progress. Waiting for it to complete..."
            for i in {1..20}; do
              NEXT_DEPLOYMENT=$(aws lightsail get-container-services --service-name "$LIGHTSAIL_SERVICE_NAME" --query "containerServices[0].nextDeployment.state" --output text)
              echo "Deployment state: $NEXT_DEPLOYMENT (attempt $i/20)"
              if [[ "$NEXT_DEPLOYMENT" == "None" || "$NEXT_DEPLOYMENT" == "FAILED" ]]; then
                break
              fi
              sleep 15
            done
          fi
          
          # Debug: Check ECR image exists
          echo "üîç Verifying ECR image exists in region $ECR_REGION..."
          IMAGE_CHECK=$(aws ecr describe-images --region "$ECR_REGION" --repository-name "$REPO_NAME" --image-ids imageTag=latest 2>&1)
          if [ $? -ne 0 ]; then
            echo "‚ùå ECR image '${ECR_REPOSITORY}:latest' not found in region $ECR_REGION"
            echo "Image check result: $IMAGE_CHECK"
            exit 1
          fi
          echo "‚úÖ ECR image verified in region $ECR_REGION"
          
          echo "üöÄ Creating Lightsail container service deployment..."
          
          DEPLOYMENT_RESULT=$(aws lightsail create-container-service-deployment \
            --service-name "$LIGHTSAIL_SERVICE_NAME" \
            --containers "{
              \"vitaluxe-app\": {
                \"image\": \"${ECR_REPOSITORY_URI}:latest\",
                \"ports\": {\"8080\": \"HTTP\"}
              }
            }" \
            --public-endpoint "{
              \"containerName\": \"vitaluxe-app\",
              \"containerPort\": 8080,
              \"healthCheck\": {\"path\": \"/\", \"intervalSeconds\": 10, \"timeoutSeconds\": 5, \"healthyThreshold\": 2, \"unhealthyThreshold\": 2}
            }" 2>&1)
          
          DEPLOYMENT_EXIT_CODE=$?
          echo "Deployment exit code: $DEPLOYMENT_EXIT_CODE"
          echo "Deployment result: $DEPLOYMENT_RESULT"
          
          if [ $DEPLOYMENT_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Failed to create deployment:"
            echo "$DEPLOYMENT_RESULT"
            
            # Additional debugging
            echo "üîç Checking service status for debugging..."
            aws lightsail get-container-services --service-name "$LIGHTSAIL_SERVICE_NAME" --query "containerServices[0].{State:state,NextDeployment:nextDeployment.state,CurrentDeployment:currentDeployment.state}" --output table
            
            exit 1
          fi
          
          echo "‚úÖ Deployment created successfully"
          echo "$DEPLOYMENT_RESULT"

      # ‚è≥ Step 7: Wait for Deployment to Complete
      - name: Wait for Lightsail Deployment
        env:
          LIGHTSAIL_SERVICE_NAME: ${{ secrets.LIGHTSAIL_SERVICE_NAME }}
        run: |
          echo "‚è≥ Waiting for deployment to complete..."
          LIGHTSAIL_SERVICE_NAME=$(echo "$LIGHTSAIL_SERVICE_NAME" | tr -d '\n' | tr -d '\r' | xargs)

          SUCCESS=false
          for i in {1..30}; do
            # Check deployment status
            DEPLOYMENT_STATE=$(aws lightsail get-container-services \
              --service-name "$LIGHTSAIL_SERVICE_NAME" \
              --query "containerServices[0].nextDeployment.state" \
              --output text)
            
            SERVICE_STATE=$(aws lightsail get-container-services \
              --service-name "$LIGHTSAIL_SERVICE_NAME" \
              --query "containerServices[0].state" \
              --output text)
            
            echo "Service state: $SERVICE_STATE | Deployment state: $DEPLOYMENT_STATE (attempt $i/30)"
            
            # Success conditions:
            # - nextDeployment.state = "None" means deployment completed and became active
            # - service.state = "RUNNING" or "READY" confirms service is operational
            if [[ "$DEPLOYMENT_STATE" == "None" && ("$SERVICE_STATE" == "RUNNING" || "$SERVICE_STATE" == "READY") ]]; then
              SUCCESS=true
              echo "‚úÖ Deployment completed successfully! Service is $SERVICE_STATE."
              break
            elif [[ "$DEPLOYMENT_STATE" == "ACTIVATING" || "$SERVICE_STATE" == "DEPLOYING" ]]; then
              echo "Still deploying... waiting 15s"
              sleep 15
            elif [[ "$DEPLOYMENT_STATE" == "FAILED" ]]; then
              echo "‚ùå Deployment failed!"
              break
            else
              echo "Waiting for deployment to progress... (15s)"
              sleep 15
            fi
          done

          if [ "$SUCCESS" = false ]; then
            echo "‚ùå Deployment did not complete successfully within timeout period"
            echo "üîç Checking final deployment status for debugging..."
            aws lightsail get-container-services \
              --service-name "$LIGHTSAIL_SERVICE_NAME" \
              --query "containerServices[0].{State:state,NextDeployment:nextDeployment.state,CurrentDeployment:currentDeployment.state}" \
              --output table
            exit 1
          fi

          echo "üîó Fetching service URL..."
          URL=$(aws lightsail get-container-services \
            --service-name "$LIGHTSAIL_SERVICE_NAME" \
            --query "containerServices[0].url" \
            --output text)
          
          if [ -z "$URL" ] || [ "$URL" = "None" ]; then
            echo "‚ùå Could not retrieve service URL"
            echo "üîç Checking service status for debugging..."
            aws lightsail get-container-services \
              --service-name "$LIGHTSAIL_SERVICE_NAME" \
              --query "containerServices[0].{State:state,Url:url,NextDeployment:nextDeployment.state}" \
              --output table
            exit 1
          fi
          
          echo "üåç Service URL: $URL"

      # üîç Step 8: Comprehensive Diagnostics
      - name: Service Diagnostics
        env:
          LIGHTSAIL_SERVICE_NAME: ${{ secrets.LIGHTSAIL_SERVICE_NAME }}
        run: |
          echo "üîç Running comprehensive service diagnostics..."
          LIGHTSAIL_SERVICE_NAME=$(echo "$LIGHTSAIL_SERVICE_NAME" | tr -d '\n' | tr -d '\r' | xargs)
          
          echo "üìä Service Status:"
          aws lightsail get-container-services \
            --service-name "$LIGHTSAIL_SERVICE_NAME" \
            --query "containerServices[0].{State:state,NextDeployment:nextDeployment.state,Url:url,Power:power,Scale:scale}" \
            --output table
          
          echo "\nüìã Container Details:"
          aws lightsail get-container-services \
            --service-name "$LIGHTSAIL_SERVICE_NAME" \
            --query "containerServices[0].currentDeployment.containers" \
            --output json
          
          echo "\nüìù Recent Container Logs (Lightsail):"
          # Fetch last 200 log events from the container service directly
          aws lightsail get-container-service-logs \
            --service-name "$LIGHTSAIL_SERVICE_NAME" \
            --container-name vitaluxe-app \
            --start-time $(date -d '15 minutes ago' +%s) \
            --end-time $(date +%s) \
            --query "logEvents[-200:].message" \
            --output text 2>/dev/null || echo "No recent log events found"

          
          echo "\nüåê Testing Service Health:"
          URL=$(aws lightsail get-container-services \
            --service-name "$LIGHTSAIL_SERVICE_NAME" \
            --query "containerServices[0].url" \
            --output text)
          
          if [ ! -z "$URL" ]; then
            echo "Testing URL: $URL"
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 10 "$URL" || echo "000")
            echo "HTTP Status: $HTTP_STATUS"
            
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "‚úÖ Service is responding with HTTP 200"
            elif [ "$HTTP_STATUS" = "000" ]; then
              echo "‚ùå Service is not responding (connection timeout or DNS issue)"
            else
              echo "‚ö†Ô∏è  Service responded with HTTP $HTTP_STATUS"
            fi
          else
            echo "‚ùå Could not retrieve service URL"
          fi

      # üßæ Step 8: Final Summary
      - name: Deployment Summary
        if: always()
        run: |
          echo "‚úÖ Vitaluxe deployment process complete."
          echo "If any rollback occurred, review the Lightsail console for details."
